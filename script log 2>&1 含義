 Linux Shell 1>/dev/null 2>&1 含義
 
 /dev/null ：代表空設備文件
>  ：代表重定向到哪裡，例如：echo "123" > /home/123.txt
1  ：表示stdout標準輸出，系統默認值是1，所以">/dev/null"等同於"1>/dev/null"
2  ：表示stderr標準錯誤
&  ：表示等同於的意思，2>&1，表示2的輸出重定向等同於1

1 > /dev/null 2>&1 語句含義：
1 > /dev/null ： 首先表示標準輸出重定向到空設備文件，也就是不輸出任何信息到終端，說白了就是不顯示任何信息。
2>&1 ：接著，標準錯誤輸出重定向（等同於）標準輸出，因為之前標準輸出已經重定向到了空設備文件，所以標準錯誤輸出也重定向到空設備文件。



兩者的不同點在於：

cmd >a 2>a 相當於使用了FD1、FD2兩個互相競爭使用文件 a 的管道；
cmd >a 2>&1 只使用了一個管道FD1，但已經包括了stdout和stderr。
從IO效率上來講，cmd >a 2>&1的效率更高。


經常可以在一些腳本，尤其是在crontab調用時發現如下形式的命令調用

/tmp/test.sh > /tmp/test.log 2>&1
前半部分/tmp/test.sh > /tmp/test.log很容易理解，那麼後面的2>&1是怎麼回事呢？

要解釋這個問題，還是得提到文件重定向。我們知道>和<是文件重定向符。那麼1和2是什麼？

在shell中，每個進程都和三個系統文件 相關聯：標準輸入stdin，標準輸出stdout、標準錯誤stderr，三個系統文件的文件描述符分別為0，1、2。所以這裡2>&1 的意思就是將標準錯誤也輸出到標準輸出當中。



下面通過一個例子來展示2>&1有什麼作用：

$ cat test.sh
t
date
test.sh中包含兩個命令，其中t是一個不存在的命令，執行會報錯，默認情況下，錯誤會輸出到stderr。date則能正確執行，並且輸出時間信息，默認輸出到stdout

./test.sh > test1.log
./test.sh: line 1: t: command not found

$ cat test1.log
Wed Jul 10 21:12:02 CST 2013


可以看到，date的執行結果被重定向到log文件中了，而t無法執行的錯誤則只打印在屏幕上。

$ ./test.sh > test2.log 2>&1

$ cat test2.log
./test.sh: line 1: t: command not found
Tue Oct 9 20:53:44 CST 2007
這次，stderr和stdout的內容都被重定向到log文件中了。



實際上， > 就相當於 1> 也就是重定向標準輸出，不包括標準錯誤。通過2>&1，就將標準錯誤重定向到標準輸出了，那麼再使用>重定向就會將標準輸出和標準錯誤信息一同重定向了。如果只想重定向標準錯誤到文件中，則可以使用2> file。

linux shell 中"2>&1"含義腳本是：
       nohup /mnt/Nand3/H2000G >/dev/null 2>&1 &


對於&1 更準確的說應該是文件描述符 1，而1 一般代表的就是STDOUT_FILENO,實際上這個操作就是一個dup2(2)調用.他標準輸出到all_result ，然後複製標準輸出到文件描述符2(STDERR_FILENO)，其後果就是文件描述符1和2指向同一個文件表項,也可以說錯誤的輸出被合併了，其中0 表示鍵盤輸入 1表示屏幕輸出 2表示錯誤輸出，把標準出錯重定向到標準輸出,然後扔到/DEV/NULL下面去。通俗的說，就是把所有標準輸出和標準出錯都扔到垃圾桶裡面。
       command >out.file 2>&1 &
       command >out.file是將command的輸出重定向到out.file文件，即輸出內容不打印到屏幕上，而是輸出到out.file文件中。 2>&1 是將標準出錯重定向到標準輸出，這裡的標準輸出已經重定向到了out.file文件，即將標準出錯也輸出到out.file文件中。最後一個& ， 是讓該命令在後台執行。
       
